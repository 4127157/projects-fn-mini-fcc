<!doctype html>
<!-- TODO : Fix Scrolling (possibly add CSS-ONLY smooth scroll-to -->
<html class="no-js" lang="en">

<head>
  <meta charset="utf-8">
  <title>Vue.js Documentation (Example Project)</title>
  <meta name="description" content="Documentation for the best framework on the
  internet according to some people">

  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta property="og:title" content="Vue.js Documentation (Example Project)">
  <meta property="og:type" content="website">

  <meta property="og:url" content="">
  <!-- TO BE DECIDED ^ -->
  <meta property="og:image" content=""> 
  <!-- temporary image -->

  <link rel="icon" href="/favicon.ico" sizes="any">
  <!-- yet to be created, use same as one created for site --> 

  <link rel="icon" href="/icon.svg" type="image/svg+xml">
  <link rel="apple-touch-icon" href="icon.png">
  <!-- same issue with favicon --> 

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@100;300;400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="css/documentation_page.css">

  <noscript>Please enable javascript in order to experience the linked projects
      better, sorry if you're inconvenienced but this is primarily a JS demo
      thing.</noscript>
  <!-- verify if screen readers can read this info here ^ (should always be at
  the bottom) -->

</head>
<body>
  <nav id='navbar'>
    <header>Vue.js Documentation</header>
    <ul>
      <li><a class='nav-link' href='#introduction'>Introduction</a></li>
      <li><a class='nav-link' href='#getting-started'>Getting Started</a></li>
      <li><a class='nav-link' href='#declarative-rendering'>Declarative Rendering</a></li>
      <li><a class='nav-link' href='#conditionals-and-loops'>Conditionals and Loops</a></li>
      <li><a class='nav-link' href='#handling-user-input'>Handling User Input</a></li>
      <li><a class='nav-link' href='#composing-with-components'>Composing With Components</a></li>
      <li><a class='nav-link' href='#creating-vue-instance'>Creating a Vue Instance</a></li>
      <li><a class='nav-link' href='#data-and-methods'>Data and Methods</a></li>
      <li><a class='nav-link' href='#instance-lifecycle-hooks'>Instance Lifecycle Hooks</a></li>
      <li><a class='nav-link' href='#interpolations'>Interpolations</a></li>
      <li><a class='nav-link' href='#directives'>Directives</a></li>

    </ul>
  </nav>

  <main id='main-doc'>
    <section class='main-section' id='introduction'>
      <header>Introduction</header>
      <article>
        <p>Vue (pronounced /vjuː/, like <strong>view</strong>) is a <strong>progressive framework</strong> for building user interfaces. Unlike other monolithic frameworks, Vue is designed from the ground up to be incrementally adoptable. The core library is focused on the view layer only, and is easy to pick up and integrate with other libraries or existing projects. On the other hand, Vue is also perfectly capable of powering sophisticated Single-Page Applications when used in combination with modern tooling and supporting libraries.</p>
        <p>Reasons to use Vue:</p>
        <ul><li>Vue is amazing!</li><li>Vue is amazing!</li><li>Vue is amazing!</li><li>Vue is amazing!</li><li>Vue is not a cult!</li></ul>
        <p>If you’d like to learn more about Vue before diving in, we created a video walking through the core principles and a sample project.</p>

        <p>If you are an experienced frontend developer and want to know how Vue compares to other libraries/frameworks, check out the Comparison with Other Frameworks.</p>

      </article>
    </section>
    <section class='main-section' id='getting-started'>
      <header>Getting Started</header>
      <article>
        <p>The easiest way to try out Vue.js is using the Hello World example. Feel free to open it in another tab and follow along as we go through some basic examples. Or, you can create an <code class='inline-code'><span class='red-text'>index.html</span></code> file and include Vue with:</p>

        <code>&lt;!-- development version, includes helpful console warnings --&gt;
          &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;</code>

        <p>or:</p>

        <code>&lt;!-- production version, optimized for size and speed --&gt;
          &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2&quot;&gt;&lt;/script&gt;</code>

        <p>The Installation page provides more options of installing Vue. Note: We do not recommend that beginners start with vue-cli, especially if you are not yet familiar with Node.js-based build tools.</p>

        <p>If you prefer something more interactive, you can also check out this tutorial series on Scrimba, which gives you a mix of screencast and code playground that you can pause and play around with anytime.</p>
      </article>
    </section>
    <section class='main-section' id='declarative-rendering'>
      <header>Declarative Rendering</header>
      <article>
        <p>At the core of Vue.js is a system that enables us to declaratively render data to the DOM using straightforward template syntax:</p>

        <code>&lt;div id=&quot;app&quot;&gt;
          {{ message }}
          &lt;/div&gt;</code>
        <code>var app = new Vue({
          el: '#app',
          data: {
          message: 'Hello Vue!'
          }
          })</code>
        <code class='code-result'>Hello Vue!</code>

        <p>We have already created our very first Vue app! This looks pretty similar to rendering a string template, but Vue has done a lot of work under the hood. The data and the DOM are now linked, and everything is now reactive. How do we know? Open your browser’s JavaScript console (right now, on this page) and set app.message to a different value. You should see the rendered example above update accordingly.</p>

        <p>Note that we no longer have to interact with the HTML directly. A Vue app attaches itself to a single DOM element (#app in our case) then fully controls it. The HTML is our entry point, but everything else happens within the newly created Vue instance.</p>

        <p>In addition to text interpolation, we can also bind element attributes like this:</p>

        <code>&lt;div id=&quot;app-2&quot;&gt;
          &lt;span v-bind:title=&quot;message&quot;&gt;
          Hover your mouse over me for a few seconds
          to see my dynamically bound title!
          &lt;/span&gt;
          &lt;/div&gt;</code>
        <code>var app2 = new Vue({
          el: '#app-2',
          data: {
          message: 'You loaded this page on ' + new Date().toLocaleString()
          }
          })</code>
        <code class='code-result'>Hover your mouse over me for a few seconds to see my dynamically bound title!</code>
        <p>Here we are encountering something new. The v-bind attribute you are seeing is called a directive. Directives are prefixed with v- to indicate that they are special attributes provided by Vue, and as you may have guessed, they apply special reactive behavior to the rendered DOM. Here, it is basically saying “keep this element’s title attribute up-to-date with the message property on the Vue instance.”</p>
        <p>If you open up your JavaScript console again and enter app2.message = 'some new message', you’ll once again see that the bound HTML - in this case the title attribute - has been updated.</p>
      </article>
    </section>
    <section class='main-section' id='conditionals-and-loops'>
      <header>Conditions and Loops</header>
      <article>
        <p>It’s easy to toggle the presence of an element, too:</p>

        <code>&lt;div id=&quot;app-3&quot;&gt;
          &lt;span v-if=&quot;seen&quot;&gt;Now you see me&lt;/span&gt;
          &lt;/div&gt;</code>
        <code>var app3 = new Vue({
          el: '#app-3',
          data: {
          seen: true
          }
          })</code>
        <code class='code-result'>Now you see me</code>

        <p>Go ahead and enter app3.seen = false in the console. You should see the message disappear</p>

        <p>This example demonstrates that we can bind data to not only text and attributes, but also the structure of the DOM. Moreover, Vue also provides a powerful transition effect system that can automatically apply transition effects when elements are inserted/updated/removed by Vue.</p>

        <p>There are quite a few other directives, each with its own special functionality. For example, the v-for directive can be used for displaying a list of items using the data from an Array:</p>
        <code>&lt;div id=&quot;app-4&quot;&gt;
          &lt;ol&gt;
          &lt;li v-for=&quot;todo in todos&quot;&gt;
          {{ todo.text }}
          &lt;/li&gt;
          &lt;/ol&gt;
          &lt;/div&gt;</code>
        <code>var app4 = new Vue({
          el: '#app-4',
          data: {
          todos: [
          { text: 'Learn JavaScript' },
          { text: 'Learn Vue' },
          { text: 'Build something awesome' }
          ]
          }
          })</code>
        <code class='code-result'>
          <ol>
            <li>Learn JavaScript</li>
            <li>Learn Vue</li>
            <li>Build something awesome</li>
          </ol>
        </code>
        <p>In the console, enter app4.todos.push({ text: 'New item' }). You should see a new item appended to the list.</p>
      </article>
    </section>
    <section class='main-section' id='handling-user-input'>
      <header>Handling User Input</header>
      <article>
        <p>To let users interact with your app, we can use the v-on directive to attach event listeners that invoke methods on our Vue instances:</p>

        <code>&lt;div id=&quot;app-5&quot;&gt;
          &lt;p&gt;{{ message }}&lt;/p&gt;
          &lt;button v-on:click=&quot;reverseMessage&quot;&gt;Reverse Message&lt;/button&gt;
          &lt;/div&gt;</code>
        <code>var app5 = new Vue({
          el: '#app-5',
          data: {
          message: 'Hello Vue.js!'
          },
          methods: {
          reverseMessage: function () {
          this.message = this.message.split('').reverse().join('')
          }
          }
          })</code>
        <code class='code-result'>Hello Vue.js! <br><button>Reverse Message</button></code>

        <p>Note that in this method we update the state of our app without touching the DOM - all DOM manipulations are handled by Vue, and the code you write is focused on the underlying logic.</p>

        <p>Vue also provides the v-model directive that makes two-way binding between form input and app state a breeze:</p>
        <code>&lt;div id=&quot;app-6&quot;&gt;
          &lt;p&gt;{{ message }}&lt;/p&gt;
          &lt;input v-model=&quot;message&quot;&gt;
          &lt;/div&gt;</code>
        <code>var app6 = new Vue({
          el: '#app-6',
          data: {
          message: 'Hello Vue!'
          }
          })</code>
        <code class='code-result'>Hello Vue!<br>
          <form><input placeholder="Hello Vue" /></form>
        </code>

      </article>
    </section>
    <section class='main-section' id='composing-with-components'>
      <header>Composing With Components</header>
      <article>
        <p>The component system is another important concept in Vue, because it’s an abstraction that allows us to build large-scale applications composed of small, self-contained, and often reusable components. If we think about it, almost any type of application interface can be abstracted into a tree of components:</p>

        <img src="https://vuejs.org/images/components.png" class='documentation-img-main' style='max-width:100%;' />

        <p>In Vue, a component is essentially a Vue instance with pre-defined options. Registering a component in Vue is straightforward:</p>

        <code>// Define a new component called todo-item
          Vue.component('todo-item', {
          template: '&lt;li&gt;This is a todo&lt;/li&gt;'
          })

          var app = new Vue(...)</code>
        <p>Now you can compose it in another component’s template:</p>
        <code>&lt;ol&gt;
          &lt;!-- Create an instance of the todo-item component --&gt;
          &lt;todo-item&gt;&lt;/todo-item&gt;
          &lt;/ol&gt;</code>
        <p>But this would render the same text for every todo, which is not super interesting. We should be able to pass data from the parent scope into child components. Let’s modify the component definition to make it accept a prop:</p>
        <code class='code-result'>Hello World!</code>

        <p>Now we can pass the todo into each repeated component using v-bind:</p>

        <code>&lt;div id=&quot;app-7&quot;&gt;
          &lt;ol&gt;
          &lt;!--
          Now we provide each todo-item with the todo object
          it's representing, so that its content can be dynamic.
          We also need to provide each component with a &quot;key&quot;,
          which will be explained later.
          --&gt;
          &lt;todo-item
          v-for=&quot;item in groceryList&quot;
          v-bind:todo=&quot;item&quot;
          v-bind:key=&quot;item.id&quot;
          &gt;&lt;/todo-item&gt;
          &lt;/ol&gt;
          &lt;/div&gt;</code>

        <code>Vue.component('todo-item', {
          props: ['todo'],
          template: '&lt;li&gt;{{ todo.text }}&lt;/li&gt;'
          })

          var app7 = new Vue({
          el: '#app-7',
          data: {
          groceryList: [
          { id: 0, text: 'Vegetables' },
          { id: 1, text: 'Cheese' },
          { id: 2, text: 'Whatever else humans are supposed to eat' }
          ]
          }
          })</code>
        <p>This is a contrived example, but we have managed to separate our app into two smaller units, and the child is reasonably well-decoupled from the parent via the props interface. We can now further improve our <todo-item> component with more complex template and logic without affecting the parent app.</p>

        <p>In a large application, it is necessary to divide the whole app into components to make development manageable. We will talk a lot more about components later in the guide, but here’s an (imaginary) example of what an app’s template might look like with components:</p>

        <code>&lt;div id=&quot;app&quot;&gt;
          &lt;app-nav&gt;&lt;/app-nav&gt;
          &lt;app-view&gt;
          &lt;app-sidebar&gt;&lt;/app-sidebar&gt;
          &lt;app-content&gt;&lt;/app-content&gt;
          &lt;/app-view&gt;
          &lt;/div&gt;</code>
      </article>
    </section>
    <section class='main-section' id='creating-vue-instance'>
      <header>Creating A Vue Instance</header>
      <article>
        <p>Every Vue application starts by creating a new Vue instance with the Vue function:</p>

        <code>var vm = new Vue({
          // options
          })</code>
        <p>Although not strictly associated with the MVVM pattern, Vue’s design was partly inspired by it. As a convention, we often use the variable vm (short for ViewModel) to refer to our Vue instance.</p>

        <p>When you create a Vue instance, you pass in an options object. The majority of this guide describes how you can use these options to create your desired behavior. For reference, you can also browse the full list of options in the API reference.</p>

        <p>A Vue application consists of a root Vue instance created with new Vue, optionally organized into a tree of nested, reusable components. For example, a todo app’s component tree might look like this:</p>

        <code>Root Instance
          └─ TodoList
          ├─ TodoItem
          │ ├─ TodoButtonDelete
          │ └─ TodoButtonEdit
          └─ TodoListFooter
          ├─ TodosButtonClear
          └─ TodoListStatistics</code>

        <p>We’ll talk about the component system in detail later. For now, just know that all Vue components are also Vue instances, and so accept the same options object (except for a few root-specific options).</p>
      </article>
    </section>
    <section class='main-section' id='data-and-methods'>
      <header>Data and Methods</header>
      <article>
        <p>When a Vue instance is created, it adds all the properties found in its data object to Vue’s reactivity system. When the values of those properties change, the view will “react”, updating to match the new values.</p>

        <code>// Our data object
          var data = { a: 1 }

          // The object is added to a Vue instance
          var vm = new Vue({
          data: data
          })

          // Getting the property on the instance
          // returns the one from the original data
          vm.a == data.a // =&gt; true

          // Setting the property on the instance
          // also affects the original data
          vm.a = 2
          data.a // =&gt; 2

          // ... and vice-versa
          data.a = 3
          vm.a // =&gt; 3</code>

        <p>When this data changes, the view will re-render. It should be noted that properties in data are only reactive if they existed when the instance was created. That means if you add a new property, like:</p>

        <code>vm.b = 'hi'</code>

        <p>Then changes to b will not trigger any view updates. If you know you’ll need a property later, but it starts out empty or non-existent, you’ll need to set some initial value. For example:</p>
        <code>data: {
          newTodoText: '',
          visitCount: 0,
          hideCompletedTodos: false,
          todos: [],
          error: null
          }</code>

        <p>The only exception to this being the use of Object.freeze(), which prevents existing properties from being changed, which also means the reactivity system can’t track changes.</p>

        <code>var obj = {
          foo: 'bar'
          }

          Object.freeze(obj)

          new Vue({
          el: '#app',
          data: obj
          })</code>

        <code>&lt;div id=&quot;app&quot;&gt;
          &lt;p&gt;{{ foo }}&lt;/p&gt;
          &lt;!-- this will no longer update `foo`! --&gt;
          &lt;button v-on:click=&quot;foo = 'baz'&quot;&gt;Change it&lt;/button&gt;
          &lt;/div&gt;</code>

        <p>In addition to data properties, Vue instances expose a number of useful instance properties and methods. These are prefixed with $ to differentiate them from user-defined properties. For example:</p>

        <code>var data = { a: 1 }
          var vm = new Vue({
          el: '#example',
          data: data
          })

          vm.$data === data // =&gt; true
          vm.$el === document.getElementById('example') // =&gt; true

          // $watch is an instance method
          vm.$watch('a', function (newValue, oldValue) {
          // This callback will be called when `vm.a` changes
          })</code>

        <p>In the future, you can consult the API reference for a full list of instance properties and methods.</p>
      </article>
    </section>
    <section class='main-section' id='instance-lifecycle-hooks'>
      <header>Instance Lifecycle Hooks</header>
      <article>
        <p>Each Vue instance goes through a series of initialization steps when it’s created - for example, it needs to set up data observation, compile the template, mount the instance to the DOM, and update the DOM when data changes. Along the way, it also runs functions called lifecycle hooks, giving users the opportunity to add their own code at specific stages.</p>

        <p>For example, the created hook can be used to run code after an instance is created:</p>
        <code>new Vue({
          data: {
          a: 1
          },
          created: function () {
          // `this` points to the vm instance
          console.log('a is: ' + this.a)
          }
          })
          // =&gt; &quot;a is: 1&quot;</code>
        <p>There are also other hooks which will be called at different stages of the instance’s lifecycle, such as mounted, updated, and destroyed. All lifecycle hooks are called with their this context pointing to the Vue instance invoking it.</p>
      </article>
    </section>
    <section class='main-section' id='interpolations'>
      <header>Interpolations</header>
      <article>
        <p>The most basic form of data binding is text interpolation using the “Mustache” syntax (double curly braces):</p>

        <code>&lt;span&gt;Message: {{ msg }}&lt;/span&gt;</code>
        <p>The mustache tag will be replaced with the value of the msg property on the corresponding data object. It will also be updated whenever the data object’s msg property changes.</p>

        <p>You can also perform one-time interpolations that do not update on data change by using the v-once directive, but keep in mind this will also affect any other bindings on the same node:</p>

        <code>&lt;span v-once&gt;This will never change: {{ msg }}&lt;/span&gt;</code>
        <p>The double mustaches interprets the data as plain text, not HTML. In order to output real HTML, you will need to use the v-html directive:</p>
        <code>&lt;p&gt;Using mustaches: {{ rawHtml }}&lt;/p&gt;
          &lt;p&gt;Using v-html directive: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt;</code>

        <p>The contents of the span will be replaced with the value of the rawHtml property, interpreted as plain HTML - data bindings are ignored. Note that you cannot use v-html to compose template partials, because Vue is not a string-based templating engine. Instead, components are preferred as the fundamental unit for UI reuse and composition.</p>

        <p>Mustaches cannot be used inside HTML attributes. Instead, use a v-bind directive:</p>
        <code>&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</code>
        <p>In the case of boolean attributes, where their mere existence implies true, v-bind works a little differently. In this example:</p>
        <code>&lt;button v-bind:disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt;</code>
        <p>If isButtonDisabled has the value of null, undefined, or false, the disabled attribute will not even be included in the rendered &lt;button&gt; element.</p>
        <p>So far we’ve only been binding to simple property keys in our templates. But Vue.js actually supports the full power of JavaScript expressions inside all data bindings:</p>
        <code>{{ number + 1 }}

          {{ ok ? 'YES' : 'NO' }}

          {{ message.split('').reverse().join('') }}

          &lt;div v-bind:id=&quot;'list-' + id&quot;&gt;&lt;/div&gt;</code>
        <p>These expressions will be evaluated as JavaScript in the data scope of the owner Vue instance. One restriction is that each binding can only contain one single expression, so the following will NOT work:</p>
        <code>&lt;!-- this is a statement, not an expression: --&gt;
          {{ var a = 1 }}

          &lt;!-- flow control won't work either, use ternary expressions --&gt;
          {{ if (ok) { return message } }}</code>

      </article>
    </section>
    <section class='main-section' id='directives'>
      <header>Directives</header>
      <article>
        <p>Directives are special attributes with the v- prefix. Directive attribute values are expected to be a single JavaScript expression (with the exception of v-for, which will be discussed later). A directive’s job is to reactively apply side effects to the DOM when the value of its expression changes. Let’s review the example we saw in the introduction:</p>

        <code>&lt;p v-if=&quot;seen&quot;&gt;Now you see me&lt;/p&gt;</code>

        <p>Here, the v-if directive would remove/insert the &lt;p&gt; element based on the truthiness of the value of the expression seen.</p>

        <p>Some directives can take an “argument”, denoted by a colon after the directive name. For example, the v-bind directive is used to reactively update an HTML attribute:</p>

        <code>&lt;a v-bind:href=&quot;url&quot;&gt; ... &lt;/a&gt;</code>
        <p>Here href is the argument, which tells the v-bind directive to bind the element’s href attribute to the value of the expression url.</p>

        <p>Another example is the v-on directive, which listens to DOM events:</p>
        <code>&lt;a v-on:click=&quot;doSomething&quot;&gt; ... &lt;/a&gt;</code>
        <p>Here the argument is the event name to listen to. We will talk about event handling in more detail too.</p>
        <p>Starting in version 2.6.0, it is also possible to use a JavaScript expression in a directive argument by wrapping it with square brackets:</p>
        <code>&lt;!--
          Note that there are some constraints to the argument expression, as explained
          in the &quot;Dynamic Argument Expression Constraints&quot; section below.
          --&gt;
          &lt;a v-bind:[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;</code>
        <p>Here attributeName will be dynamically evaluated as a JavaScript expression, and its evaluated value will be used as the final value for the argument. For example, if your Vue instance has a data property, attributeName, whose value is "href", then this binding will be equivalent to v-bind:href.</p>
        <p>Similarly, you can use dynamic arguments to bind a handler to a dynamic event name:</p>
        <code>&lt;a v-on:[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;</code>
        <p>In this example, when eventName‘s value is "focus", v-on:[eventName] will be equivalent to v-on:focus</p>
        <p>Dynamic arguments are expected to evaluate to a string, with the exception of null. The special value null can be used to explicitly remove the binding. Any other non-string value will trigger a warning.</p>
        <p>Dynamic argument expressions have some syntax constraints because certain characters, such as spaces and quotes, are invalid inside HTML attribute names. For example, the following is invalid:</p>
        <code>&lt;!-- This will trigger a compiler warning. --&gt;
          &lt;a v-bind:['foo' + bar]=&quot;value&quot;&gt; ... &lt;/a&gt;</code>
        <p>The workaround is to either use expressions without spaces or quotes, or replace the complex expression with a computed property.</p>
        <p>When using in-DOM templates (i.e., templates written directly in an HTML file), you should also avoid naming keys with uppercase characters, as browsers will coerce attribute names into lowercase:</p>
        <code>&lt;!--
          This will be converted to v-bind:[someattr] in in-DOM templates.
          Unless you have a &quot;someattr&quot; property in your instance, your code won't work.
          --&gt;
          &lt;a v-bind:[someAttr]=&quot;value&quot;&gt; ... &lt;/a&gt;</code>
        <p>Modifiers are special postfixes denoted by a dot, which indicate that a directive should be bound in some special way. For example, the .prevent modifier tells the v-on directive to call event.preventDefault() on the triggered event:</p>
        <code>&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt; ... &lt;/form&gt;</code>
        <p>You’ll see other examples of modifiers later, for v-on and for v-model, when we explore those features.</p>
      </article>
    </section>
  </main>
</body>
</html>

